<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PQC Analysis - README</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 900px;
            margin: 20px auto;
            padding: 0 20px;
            background-color: #f4f4f4;
        }
        h1, h2, h3 {
            color: #0056b3;
        }
        pre {
            background-color: #eee;
            padding: 10px;
            border-radius: 5px;
            overflow-x: auto;
        }
        code {
            font-family: "Courier New", Courier, monospace;
            background-color: #e9e9e9;
            padding: 2px 4px;
            border-radius: 3px;
        }
        .container {
            background-color: #fff;
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
        }
        ul {
            list-style-type: disc;
            margin-left: 20px;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 15px;
        }
        table, th, td {
            border: 1px solid #ddd;
        }
        th, td {
            padding: 10px;
            text-align: left;
        }
        th {
            background-color: #f2f2f2;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>PQC Analysis</h1>

        <p>This repository provides Python code for analyzing the geometric and topological properties of Parameterized Quantum Circuits (PQCs) using PennyLane, PyTorch, and Ripser.</p>

        <h2>Installation</h2>
        <p>To use this package, you need to have PennyLane, PyTorch, NumPy, TQDM, Tabulate, and Ripser installed. You can install them via pip:</p>
        <pre><code>pip install pennylane pennylane-lightning[torch] torch numpy tqdm tabulate ripser</code></pre>

        <h2>Package Structure</h2>
        <p>The core functionality is organized into two main modules within the <code>pqc_analysis</code> directory:</p>
        <ul>
            <li><code>geometry_analysis.py</code>: Contains functions to compute the Fubini-Study metric tensor and related geometric properties of PQCs.</li>
            <li><code>topology_analysis.py</code>: Contains functions to perform topological data analysis (TDA) on the state space of PQCs using persistent homology.</li>
        </ul>

        <h2>Usage</h2>

        <h3>Geometry Analysis</h3>
        <p>The <code>pqc_geometry_analysis</code> function allows you to assess the local expressibility and redundancy of a PQC by analyzing its Fubini-Study metric tensor.</p>

        <h4><code>pqc_geometry_analysis(pqc, n_params, n_qubits, n_samples=100, init_strategy='uniform', init_thetas=None, **kwargs)</code></h4>
        <ul>
            <li><code>pqc</code> (callable): A PennyLane QNode representing the Parameterized Quantum Circuit. This function should take a <code>params</code> argument (a 1D NumPy array or Torch tensor of parameters) and return a quantum state (e.g., <code>qml.state()</code>).</li>
            <li><code>n_params</code> (int): The number of parameters in the PQC.</li>
            <li><code>n_qubits</code> (int): The number of qubits in the PQC.</li>
            <li><code>n_samples</code> (int, optional): The number of random parameter sets to sample for analysis. Defaults to 100.</li>
            <li><code>init_strategy</code> (str or callable, optional): Strategy for initializing parameters. Can be <code>'uniform'</code> (parameters sampled uniformly from <code>[-pi, pi]</code>), <code>'normal'</code> (parameters sampled from a normal distribution with mean 0 and std dev <code>pi</code>), or a custom callable function that takes <code>n_params</code> and returns a 1D NumPy array of parameters. Defaults to <code>'uniform'</code>.</li>
            <li><code>init_thetas</code> (numpy.ndarray, optional): A pre-defined NumPy array of shape <code>(n_samples, n_params)</code> containing the parameter sets to use. If provided, <code>init_strategy</code> is ignored.</li>
            <li><code>**kwargs</code>: Additional keyword arguments to pass to the PQC QNode.</li>
        </ul>

        <h4>Returns:</h4>
        <p>A dictionary summarizing the geometric metrics:</p>
        <ul>
            <li><code>Total Volume</code>: The estimated total volume of the PQC's reachable state space.</li>
            <li><code>Avg Local Volume</code>: The average local volume (square root of the determinant of the Fubini-Study metric tensor).</li>
            <li><code>Avg Metric Rank</code>: The average rank of the Fubini-Study metric tensor.</li>
            <li><code>Redundant Param Ratio</code>: The proportion of sampled parameter sets where the metric tensor has a rank less than <code>n_params</code>, indicating parameter redundancy.</li>
            <li><code>Avg Gamma (Cond # Inv)</code>: The average condition number (inverse of the ratio of minimum to maximum eigenvalue) of the metric tensor, indicating how well-conditioned the optimization landscape is.</li>
            <li><code>Num Params</code>: The number of parameters used in the analysis.</li>
            <li><code>Num Qubits</code>: The number of qubits used in the analysis.</li>
        </ul>

        <h4>Example:</h4>
        <pre><code class="language-python">import pennylane as qml
from pennylane import numpy as np
from pqc_analysis.geometry_analysis import pqc_geometry_analysis

# Define a simple PQC (e.g., Circuit1 from the analysis)
def my_pqc(params):
    qml.RX(params[0], wires=0)
    qml.RZ(params[1], wires=0)
    qml.RX(params[2], wires=1)
    qml.RZ(params[3], wires=1)
    return qml.state()

n_qubits_example = 2
n_params_example = 4

# Run geometry analysis
summary = pqc_geometry_analysis(
    pqc=my_pqc,
    n_params=n_params_example,
    n_qubits=n_qubits_example,
    n_samples=500,
    init_strategy='uniform'
)
print(summary)
</code></pre>

        <h3>Topology Analysis</h3>
        <p>The <code>pqc_topology_analysis</code> function uses Persistent Homology to infer topological features (e.g., holes, connected components) of the manifold traced by the PQC in the quantum state space.</p>

        <h4><code>pqc_topology_analysis(pqc, n_params, n_qubits, n_samples=100, max_dim=2, init_strategy='normal', init_thetas=None, **kwargs)</code></h4>
        <ul>
            <li><code>pqc</code> (callable): A PennyLane QNode representing the Parameterized Quantum Circuit. This function should take a <code>params</code> argument (a 1D NumPy array or Torch tensor of parameters) and return a quantum state (e.g., <code>qml.state()</code>).</li>
            <li><code>n_params</code> (int): The number of parameters in the PQC.</li>
            <li><code>n_qubits</code> (int): The number of qubits in the PQC.</li>
            <li><code>n_samples</code> (int, optional): The number of random parameter sets to sample for state generation. Defaults to 100.</li>
            <li><code>max_dim</code> (int, optional): The maximum homology dimension to compute. Defaults to 2.</li>
            <li><code>init_strategy</code> (str or callable, optional): Strategy for initializing parameters. Can be <code>'uniform'</code> (parameters sampled uniformly from <code>[-pi, pi]</code>), <code>'normal'</code> (parameters sampled from a normal distribution with mean 0 and std dev <code>pi</code>), or a custom callable function that takes <code>n_params</code> and returns a 1D NumPy array of parameters. Defaults to <code>'normal'</code>.</li>
            <li><code>init_thetas</code> (numpy.ndarray, optional): A pre-defined NumPy array of shape <code>(n_samples, n_params)</code> containing the parameter sets to use. If provided, <code>init_strategy</code> is ignored.</li>
            <li><code>**kwargs</code>: Additional keyword arguments to pass to the PQC QNode.</li>
        </ul>

        <h4>Returns:</h4>
        <p>A list of floats, where each element represents the Shannon entropy of the lifetime distribution for the corresponding homology dimension H_k. Higher entropy indicates more complex topological features.</p>

        <h4>Example:</h4>
        <pre><code class="language-python">import pennylane as qml
from pennylane import numpy as np
from pqc_analysis.topology_analysis import pqc_topology_analysis

# Define a simple PQC (e.g., Circuit2 from the analysis)
def my_pqc_topology(params):
    qml.RX(params[0], wires=0)
    qml.RZ(params[1], wires=0)
    qml.CNOT(wires=[0, 1])
    return qml.state()

n_qubits_topology_example = 2
n_params_topology_example = 2

# Run topology analysis
entropy_values = pqc_topology_analysis(
    pqc=my_pqc_topology,
    n_params=n_params_topology_example,
    n_qubits=n_qubits_topology_example,
    n_samples=200,
    max_dim=1
)
print("Entropy values for different homology dimensions:", entropy_values)
</code></pre>

        <h2>Contributing</h2>
        <p>Feel free to contribute to this project by opening issues or submitting pull requests.</p>

        <h2>License</h2>
        <p>This project is open-sourced under the MIT License.</p>
    </div>
</body>
</html>
